{
    "docs": [
        {
            "location": "/",
            "text": "Rodux is a central state management library based on Dan Abramov's \nRedux\n library for JavaScript. It exposes a very similar API and implements nearly identical semantics.\n\n\nThis documentation is based on the structure of Redux's documentation, but is a work in progress. Many things from Redux also apply to Rodux, but if you find anything missing or incorrect, \nopen an issue on GitHub\n!\n\n\n\n\nInfo\n\n\nThis documentation assumes some familiarity with Lua. If you're new to Lua, \nProgramming in Lua\n by Roberto Ierusalimschy\n is a good introduction, and the first edition (for Lua 5.0) is available online for free.",
            "title": "Home"
        },
        {
            "location": "/introduction/installation/",
            "text": "There are two supported ways to get started with Rodux.\n\n\nFor our examples, we'll install \nRodux\n to \nReplicatedStorage\n. In practice, it's okay to install Rodux anywhere you want!\n\n\nMethod 1: Model File (Roblox Studio)\n\u00b6\n\n\n\n\nDownload the \nrbxmx\n model file attached to the latest release from the \nGitHub releases page\n.\n\n\nInsert the model into Studio into a place like \nReplicatedStorage\n\n\n\n\nMethod 2: Filesystem\n\u00b6\n\n\n\n\nCopy the \nlib\n directory into your codebase\n\n\nRename the folder to \nRodux\n\n\nUse a plugin like \nRojo\n to sync the files into a place",
            "title": "Installation"
        },
        {
            "location": "/introduction/installation/#method-1-model-file-roblox-studio",
            "text": "Download the  rbxmx  model file attached to the latest release from the  GitHub releases page .  Insert the model into Studio into a place like  ReplicatedStorage",
            "title": "Method 1: Model File (Roblox Studio)"
        },
        {
            "location": "/introduction/installation/#method-2-filesystem",
            "text": "Copy the  lib  directory into your codebase  Rename the folder to  Rodux  Use a plugin like  Rojo  to sync the files into a place",
            "title": "Method 2: Filesystem"
        },
        {
            "location": "/introduction/motivation/",
            "text": "As applications become more complex it can be difficult to manage the state of our application in a way that is transparent and compartmentalized. State changes caused by network responses and user input become difficult to follow as our business logic gets spread out between an increasing number of models and views, producing unpredictable and undesirable results. Rodux tries to address this problem by following three core principles.\n\n\nSingle Source of Truth\n\u00b6\n\n\nBy collecting all of our application's state in a single object, we can quickly inspect the entirety of the data backing our business logic. We will no longer need to track down data models squirrelled away in disparate parts of our code base.\n\n\nState is Read-only\n\u00b6\n\n\nAll changes to our single state object are accomplished by dispatching actions to our store, so which part of our code caused what changes to our underlying data will be completely transparent and reproducible. Features that were once difficult like undo/redo become trivial when all changes to our data are controlled via a single, consistent interface.\n\n\nChanges Are Made With Pure Functions\n\u00b6\n\n\nActions dispatched to our store will be processed by pure functions called reducers. These reducers simply take an action and our store's current state as input and output the store's new state in response to that action. These functions have no side effects and give us a single location to put all of our business logic instead of spreading that business logic out over numerous views and models.\n\n\nThat's all there is to it! The API and tools Rodux provides are relatively simple, but solve many of the most common problems that occur in complex, asynchronous applications by introducing a single paradigm for all of our data management.",
            "title": "Motivation"
        },
        {
            "location": "/introduction/motivation/#single-source-of-truth",
            "text": "By collecting all of our application's state in a single object, we can quickly inspect the entirety of the data backing our business logic. We will no longer need to track down data models squirrelled away in disparate parts of our code base.",
            "title": "Single Source of Truth"
        },
        {
            "location": "/introduction/motivation/#state-is-read-only",
            "text": "All changes to our single state object are accomplished by dispatching actions to our store, so which part of our code caused what changes to our underlying data will be completely transparent and reproducible. Features that were once difficult like undo/redo become trivial when all changes to our data are controlled via a single, consistent interface.",
            "title": "State is Read-only"
        },
        {
            "location": "/introduction/motivation/#changes-are-made-with-pure-functions",
            "text": "Actions dispatched to our store will be processed by pure functions called reducers. These reducers simply take an action and our store's current state as input and output the store's new state in response to that action. These functions have no side effects and give us a single location to put all of our business logic instead of spreading that business logic out over numerous views and models.  That's all there is to it! The API and tools Rodux provides are relatively simple, but solve many of the most common problems that occur in complex, asynchronous applications by introducing a single paradigm for all of our data management.",
            "title": "Changes Are Made With Pure Functions"
        },
        {
            "location": "/introduction/store/",
            "text": "The \nstore\n is comprised of three parts and is your main entry point for all things Rodux. It is created via \nStore.new\n.\n\n\nState\n\u00b6\n\n\nThis is the object that contains all of the data backing the business logic of your application. It is usually represented as a Lua table and it can be read via \nStore:getState\n.\n\n\nlocal\n \nexampleState\n \n=\n \n{\n\n    \nmyPhoneNumber\n \n=\n \n\"15552345678\"\n,\n\n    \nmyFriends\n \n=\n \n{\n\n        \n\"Joe\"\n,\n\n        \n\"Cassandra\"\n,\n\n    \n},\n\n\n}\n\n\n\n\n\nReducer\n\u00b6\n\n\nThis is a pure function that takes in an \naction\n object and the current state of your \nstore\n and outputs a new state in response to the \naction\n. Reducers are often broken down into many individual pure functions, each of which modifies one portion of the state. You provide your global \nreducer\n to the \nstore\n during initialization via \nStore.new\n. See the \nReducer\n page for more details.\n\n\nDispatcher\n\u00b6\n\n\nThis is the function of the \nstore\n that handles incoming \naction\n objects and forwards them to your \nreducer\n. If you have applied any \nmiddleware\n to your \nstore\n, the \nmiddleware\n will wrap this \ndispatcher\n function and reassign it such that the \naction\n will be passed through all of the \nmiddleware\n you provided to your \nstore\n before forwarding the \naction\n object to the \nreducer\n. You can provide \nmiddleware\n to the \nstore\n during initialization via \nStore.new\n.\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nfunction\n(\naction\n,\n \ncurrentState\n)\n\n    \n-- The body of your reducer\n\n\nend\n)\n\n\n\nlocal\n \nstate\n \n=\n \nstore\n:\ngetState\n()",
            "title": "The Store"
        },
        {
            "location": "/introduction/store/#state",
            "text": "This is the object that contains all of the data backing the business logic of your application. It is usually represented as a Lua table and it can be read via  Store:getState .  local   exampleState   =   { \n     myPhoneNumber   =   \"15552345678\" , \n     myFriends   =   { \n         \"Joe\" , \n         \"Cassandra\" , \n     },  }",
            "title": "State"
        },
        {
            "location": "/introduction/store/#reducer",
            "text": "This is a pure function that takes in an  action  object and the current state of your  store  and outputs a new state in response to the  action . Reducers are often broken down into many individual pure functions, each of which modifies one portion of the state. You provide your global  reducer  to the  store  during initialization via  Store.new . See the  Reducer  page for more details.",
            "title": "Reducer"
        },
        {
            "location": "/introduction/store/#dispatcher",
            "text": "This is the function of the  store  that handles incoming  action  objects and forwards them to your  reducer . If you have applied any  middleware  to your  store , the  middleware  will wrap this  dispatcher  function and reassign it such that the  action  will be passed through all of the  middleware  you provided to your  store  before forwarding the  action  object to the  reducer . You can provide  middleware  to the  store  during initialization via  Store.new .  local   store   =   Rodux . Store . new ( function ( action ,   currentState ) \n     -- The body of your reducer  end )  local   state   =   store : getState ()",
            "title": "Dispatcher"
        },
        {
            "location": "/introduction/actions/",
            "text": "Whenever the \nstate\n in your \nstore\n needs to be updated in response to an event, you \ndispatch\n an \naction\n to your \nstore\n with any relevant information required to make said update. An \naction\n is usually a Lua table with a \ntype\n field. They are usually created via an action creator Lua module like the following:\n\n\nlocal\n \nfunction\n \nReceivedNewPhoneNumber\n(\nphoneNumber\n)\n\n    \nreturn\n \n{\n\n        \ntype\n \n=\n \n\"ReceivedNewPhoneNumber\"\n,\n\n        \nphoneNumber\n \n=\n \nphoneNumber\n,\n\n    \n}\n\n\nend\n\n\n\nreturn\n \nReceivedNewPhoneNumber\n\n\n\n\n\nWe can then \ndispatch\n an \naction\n to our \nstore\n via \nStore:dispatch\n like so:\n\n\nlocal\n \nstore\n \n=\n \nStore\n.\nnew\n(\nfunction\n(\ncurrentState\n,\n \naction\n)\n\n    \n-- The body of your reducer\n\n\nend\n)\n\n\n\nstore\n:\ndispatch\n(\nReceivedNewPhoneNumber\n(\n\"15552345678\"\n))\n\n\n\n\n\n\n\nInfo\n\n\nIn most cases your \naction\n will be sent directly to the \nreducer\n to be processed. However, if you specified any \nmiddleware\n when initializing your \nstore\n, your \naction\n might also be processed by that \nmiddleware\n.",
            "title": "Actions"
        },
        {
            "location": "/introduction/reducers/",
            "text": "When you initialize your \nstore\n with \nStore.new\n, you provide a single function called a \nreducer\n which will consume any \naction\n dispatched to your \nstore\n and create a new \nstate\n object based on the current \nstate\n of your \nstore\n.\n\n\nlocal\n \nphoneNumberReducer\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n    \nif\n \naction\n.\ntype\n \n==\n \n\"ReceivedNewPhoneNumber\"\n \nthen\n\n        \nreturn\n \naction\n.\nphoneNumber\n\n    \nend\n\n\n    \nreturn\n \nstate\n\n\nend\n\n\n\n\n\nNote that \nstate\n is never actually modified by our \nreducer\n. The \nstate\n of our \nstore\n is \nread-only\n, so our \nreducer\n must construct a new \nstate\n object in response to the received \naction\n.\n\n\nFor complex applications, it is often useful to break down the global \nreducer\n you provide to the \nstore\n into a set of smaller \nreducer\n functions, each of which is responsible for a portion of the \nstate\n.\n\n\nlocal\n \nfriendsReducer\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n    \n--[[\n\n\n        The state might be nil the first time this reducer is executed.\n\n\n        In that case, we need to initialize our state to be the empty table.\n\n\n    ]]\n\n    \nstate\n \n=\n \nstate\n \nor\n \n{}\n\n\n    \nif\n \naction\n.\ntype\n \n==\n \n\"MadeNewFriends\"\n \nthen\n\n        \nlocal\n \nnewState\n \n=\n \n{}\n\n\n        \n-- Since state is read-only, we copy it into newState\n\n        \nfor\n \nindex\n,\n \nfriend\n \nin\n \nipairs\n(\nstate\n)\n \ndo\n\n            \nnewState\n[\nindex\n]\n \n=\n \nfriend\n\n        \nend\n\n\n        \nfor\n \n_\n,\n \nfriend\n \nin\n \nipairs\n(\naction\n.\nnewFriends\n)\n\n            \ntable.insert\n(\nnewState\n,\n \nfriend\n)\n\n        \nend\n\n\n        \nreturn\n \nnewState\n\n    \nend\n\n\n    \nreturn\n \nstate\n\n\nend\n\n\n\n--[[\n\n\n    note that the reducer for our entire application is defined by a table of\n\n\n    sub-reducers where each sub-reducer is responsible for one portion of the\n\n\n    overall state.\n\n\n]]\n\n\nlocal\n \nreducer\n \n=\n \nfunction\n(\naction\n,\n \nstate\n)\n\n    \nreturn\n \n{\n\n        \nmyPhoneNumber\n \n=\n \nphoneNumberReducer\n(\nstate\n.\nmyPhoneNumber\n,\n \naction\n),\n\n        \nmyFriends\n \n=\n \nfriendsReducer\n(\nstate\n.\nmyFriends\n,\n \naction\n),\n\n    \n}\n\n\nend\n\n\n\n\n\nAlternatively, you can use \nRodux.createReducer\n and \nRodux.combineReducers\n to generate the same code as seen above. Using \nRodux.createReducer\n and \nRodux.combineReducers\n to create your \nreducer\n functions isn't as verbose and is less prone to developer error.\n\n\nlocal\n \nphoneNumberReducer\n \n=\n \nRodux\n.\ncreateReducer\n(\nnil\n,\n \n{\n\n    \nReceivedNewPhoneNumber\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n        \nreturn\n \naction\n.\nphoneNumber\n\n    \nend\n,\n\n\n})\n\n\n\nlocal\n \nfriendsReducer\n \n=\n \nRodux\n.\ncreateReducer\n({},\n \n{\n\n    \nMadeNewFriends\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n        \nlocal\n \nnewState\n \n=\n \n{}\n\n\n        \n-- Since state is read-only, we copy it into newState\n\n        \nfor\n \nindex\n,\n \nfriend\n \nin\n \nipairs\n(\nstate\n)\n \ndo\n\n            \nnewState\n[\nindex\n]\n \n=\n \nfriend\n\n        \nend\n\n\n        \nfor\n \n_\n,\n \nfriend\n \nin\n \nipairs\n(\naction\n.\nfriends\n)\n\n            \ntable.insert\n(\nnewState\n,\n \nfriend\n)\n\n        \nend\n\n\n        \nreturn\n \nnewState\n\n    \nend\n,\n\n\n})\n\n\n\nlocal\n \nreducer\n \n=\n \nRodux\n.\ncombineReducers\n({\n\n    \nmyPhoneNumber\n \n=\n \nphoneNumberReducer\n,\n\n    \nmyFriends\n \n=\n \nfriendsReducer\n,\n\n\n})",
            "title": "Reducers"
        },
        {
            "location": "/advanced/middleware/",
            "text": "Most of the time, calling \nStore:dispatch\n sends incoming \naction\n objects directly to the \nreducer\n to determine what updates should be made to the \nstate\n. This is enough for most cases, but some features would be difficult to implement if this was all Rodux provided. For example:\n\n\n\n\nDelayed processing of an \naction\n.\n\n\nLogging \naction\n objects dispatched to our \nstore\n.\n\n\nPerforming a network request in response to an \naction\n and storing the response in the \nstate\n.\n\n\n\n\nRodux has the concept of \nmiddleware\n to deal with these sorts of situations.\n\n\nA \nmiddleware\n is a function that accepts the next \ndispatch\n function in the \nmiddleware\n chain, as well as the \nstore\n the \nmiddleware\n is being used with, and returns a new function. That function is called whenever an \naction\n is dispatched and can dispatch more \nactions\n, log to output, or perform any other side effects! When an \naction\n is dispatched, \nmiddleware\n are run in the order they were specified in \nStore.new\n from left to right.\n\n\nHere is an example of a \nmiddleware\n that could be used to delay the processing of \naction\n objects dispatched to the \nstore\n.\n\n\nlocal\n \nreducer\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n    \n-- the body of your reducer\n\n\nend\n\n\n\nlocal\n \ninitialState\n \n=\n \n{}\n\n\n\nlocal\n \ndelayOneSecondMiddleware\n \n=\n \nfunction\n(\nnextDispatch\n,\n \nstore\n)\n\n    \nreturn\n \nfunction\n(\naction\n)\n\n        \ndelay\n(\n1\n,\n \nfunction\n()\n\n            \n--[[\n\n\n                nextDispatch passes the action to the next middleware provided\n\n\n                to the store at initialization or to the reducer if the action\n\n\n                has already been processed by all the provided middleware.\n\n\n            ]]\n\n            \nnextDispatch\n(\naction\n)\n\n        \nend\n)\n\n    \nend\n\n\nend\n\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nreducer\n,\n \ninitialState\n,\n \n{\n\n    \ndelayOneSecondMiddleware\n,\n\n\n})\n\n\n\n\n\n\n\nWarning\n\n\nIf the \ndelayOneSecondMiddleware\n function did not call \nnextDispatch\n, then the \naction\n would not be processed by any other \nmiddleware\n in the \nmiddleware\n chain or our \nreducer\n!\n\n\n\n\nRodux has two \nmiddlewares\n available to you out of the box. See \nMiddleware\n, \nthunkMiddleware\n, and \nloggerMiddleware\n for more details.",
            "title": "Middleware"
        },
        {
            "location": "/advanced/thunks/",
            "text": "The \nthunkMiddleware\n packaged with Rodux will intercept any \naction\n dispatched to our \nstore\n that is a Lua \nfunction\n and execute that function instead of forwarding our \naction\n to the \nreducer\n. These functions (also called thunks) have access to the \nstore\n and are allowed to dispatch \naction\n objects themselves as necessary.\n\n\nlocal\n \nreducer\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n    \n--[[\n\n\n        Reducer that handles all actions for our store,\n\n\n        including actions of the type \"MadeNewFriends\".\n\n\n    ]]\n\n\nend\n\n\n\nlocal\n \ninitialState\n \n=\n \n{}\n\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nreducer\n,\n \ninitialState\n,\n \n{\n\n    \nRodux\n.\nthunkMiddleware\n,\n\n\n})\n\n\n\n--[[\n\n\n    Our thunkMiddleware will process this action as a thunk\n\n\n    since it is a Lua function\n\n\n]]\n\n\nstore\n:\ndispatch\n(\nfunction\n(\nstore\n)\n\n    \ngetAsyncNewFriendsForUser\n(\n\"Sarah\"\n,\n \nfunction\n(\nresult\n)\n\n        \nstore\n:\ndispatch\n({\n\n            \ntype\n \n=\n \n\"MadeNewFriends\"\n,\n\n            \nnewFriends\n \n=\n \nresult\n,\n\n        \n})\n\n    \nend\n)\n\n\nend\n)\n\n\n\n\n\nThunks are a simple way to introduce more complex processing of \naction\n objects, but you may want to consider creating custom \nmiddleware\n for complex features instead of relying on thunks alone.",
            "title": "Thunks"
        },
        {
            "location": "/example/",
            "text": "The following is an example of a Rodux store that keeps track of the current user's phone number and the names of their friends. It demonstrates the use of the Rodux \nstore\n, \nactions\n, \nreducers\n, and \nmiddleware\n in a real world setting. The \nloggerMiddleware\n has been included to demonstrate how to include \nmiddleware\n in your \nstore\n and to provide valuable output in response to dispatched \naction\n objects.\n\n\n\n\nInfo\n\n\nThis example assumes that you've successfully \ninstalled Rodux\n into \nReplicatedStorage\n and placed the contents of the following in a LocalScript under \nStarterPlayer/StarterPlayerScripts\n!\n\n\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRodux\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRodux\n)\n\n\n\n-- Action creator for the ReceivedNewPhoneNumber action\n\n\nlocal\n \nfunction\n \nReceivedNewPhoneNumber\n(\nphoneNumber\n)\n\n    \nreturn\n \n{\n\n        \ntype\n \n=\n \n\"ReceivedNewPhoneNumber\"\n,\n\n        \nphoneNumber\n \n=\n \nphoneNumber\n,\n\n    \n}\n\n\nend\n\n\n\n-- Action creator for the MadeNewFriends action\n\n\nlocal\n \nfunction\n \nMadeNewFriends\n(\nlistOfNewFriends\n)\n\n    \nreturn\n \n{\n\n        \ntype\n \n=\n \n\"MadeNewFriends\"\n,\n\n        \nnewFriends\n \n=\n \nlistOfNewFriends\n,\n\n    \n}\n\n\nend\n\n\n\n-- Reducer for the current user's phone number\n\n\nlocal\n \nphoneNumberReducer\n \n=\n \nRodux\n.\ncreateReducer\n(\n\"\"\n,\n \n{\n\n    \nReceivedNewPhoneNumber\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n        \nreturn\n \naction\n.\nphoneNumber\n\n    \nend\n,\n\n\n})\n\n\n\n-- Reducer for the current user's list of friends\n\n\nlocal\n \nfriendsReducer\n \n=\n \nRodux\n.\ncreateReducer\n({},\n \n{\n\n    \nMadeNewFriends\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n        \nlocal\n \nnewState\n \n=\n \n{}\n\n\n        \n-- Since state is read-only, we copy it into newState\n\n        \nfor\n \nindex\n,\n \nfriend\n \nin\n \nipairs\n(\nstate\n)\n \ndo\n\n            \nnewState\n[\nindex\n]\n \n=\n \nfriend\n\n        \nend\n\n\n        \nfor\n \n_\n,\n \nfriend\n \nin\n \nipairs\n(\naction\n.\nnewFriends\n)\n \ndo\n\n            \ntable.insert\n(\nnewState\n,\n \nfriend\n)\n\n        \nend\n\n\n        \nreturn\n \nnewState\n\n    \nend\n,\n\n\n})\n\n\n\nlocal\n \nreducer\n \n=\n \nRodux\n.\ncombineReducers\n({\n\n    \nmyPhoneNumber\n \n=\n \nphoneNumberReducer\n,\n\n    \nmyFriends\n \n=\n \nfriendsReducer\n,\n\n\n})\n\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nreducer\n,\n \nnil\n,\n \n{\n\n    \nRodux\n.\nloggerMiddleware\n,\n\n\n})\n\n\n\nstore\n:\ndispatch\n(\nReceivedNewPhoneNumber\n(\n\"15552345678\"\n))\n\n\nstore\n:\ndispatch\n(\nMadeNewFriends\n({\n\n    \n\"Cassandra\"\n,\n\n    \n\"Joe\"\n,\n\n\n}))\n\n\n\n--[[\n\n\n    Expected output to the developer console:\n\n\n\n    Action dispatched: {\n\n\n        phoneNumber = \"12345678\" (string)\n\n\n        type = \"ReceivedNewPhoneNumber\" (string)\n\n\n    }\n\n\n    State changed to: {\n\n\n        myPhoneNumber = \"12345678\" (string)\n\n\n        myFriends = {\n\n\n        }\n\n\n    }\n\n\n    Action dispatched: {\n\n\n        newFriends = {\n\n\n            1 = \"Cassandra\" (string)\n\n\n            2 = \"Joe\" (string)\n\n\n        }\n\n\n        type = \"MadeNewFriends\" (string)\n\n\n    }\n\n\n    State changed to: {\n\n\n        myPhoneNumber = \"12345678\" (string)\n\n\n        myFriends = {\n\n\n            1 = \"Cassandra\" (string)\n\n\n            2 = \"Joe\" (string)\n\n\n        }\n\n\n    }\n\n\n]]",
            "title": "Complete Example"
        },
        {
            "location": "/debugging/",
            "text": "In the future, Rodux will have tools similar to \nRedux's DevTools\n and will be documented here. For now, we highly recommend using the \nloggerMiddleware\n to observe the \nstate\n as \naction\n objects are dispatched to your \nstore\n.",
            "title": "Debugging"
        },
        {
            "location": "/withroact/",
            "text": "Rodux stands well on its own and does not require any additional libraries. However, Rodux can be particularly useful when developing Roact applications. It is difficult to represent global state in Roact without passing a lot of data up and down the Roact DOM. \nRoactRodux\n allows us to connect individual Roact components to our Rodux store, simplifying the management of our application's global state.",
            "title": "Usage with Roact"
        },
        {
            "location": "/api-reference/",
            "text": "Rodux API Reference\n\u00b6\n\n\nRodux.Store\n\u00b6\n\n\nThe Store class is the core piece of Rodux. It is the state container that you create and use.\n\n\nStore.new\n\u00b6\n\n\nStore.new(reducer, [initialState, [middlewares]]) -> Store\n\n\n\n\nCreates and returns a new Store.\n\n\n\n\nreducer\n is the store's root reducer function, and is invokved whenever an action is dispatched. It must be a pure function.\n\n\ninitialState\n is the store's initial state. This should be used to load a saved state from storage.\n\n\nmiddlewares\n is a list of middleware to apply to the store.\n\n\n\n\nThe store will automatically dispatch an initialization action with a \ntype\n of \n@@INIT\n.\n\n\n\n\nNote\n\n\nThe initialization action does not pass through any middleware prior to reaching the reducer.\n\n\n\n\nStore.changed\n\u00b6\n\n\nstore\n.\nchanged\n:\nconnect\n(\nfunction\n(\nnewState\n,\n \noldState\n)\n\n    \n-- do something with newState or oldState\n\n\nend\n)\n\n\n\n\n\nA \nSignal\n that is fired when the store's state is changed up to once per frame.\n\n\n\n\nWarning\n\n\nMultiple actions can be grouped together into one changed event!\n\n\n\n\n\n\nDanger\n\n\nDo not yield within any listeners on \nchanged\n; an error will be thrown.\n\n\n\n\nStore:dispatch\n\u00b6\n\n\nstore:dispatch(action) -> nil\n\n\n\n\nDispatches an action. The action will travel through all of the store's middlewares before reaching the store's reducer.\n\n\nUnless handled by middleware, \naction\n must contain a \ntype\n field to indicate what type of action it is. No other fields are required.\n\n\nStore:getState\n\u00b6\n\n\nstore:getState() -> table\n\n\n\n\nGets the store's current state.\n\n\n\n\nWarning\n\n\nDo not modify this state! Doing so will cause \nserious\n bugs your code!\n\n\n\n\nStore:destruct\n\u00b6\n\n\nstore:destruct() -> nil\n\n\n\n\nDestroys the store, cleaning up its connections.\n\n\n\n\nDanger\n\n\nAttempting to use the store after \ndestruct\n has been called will cause problems.\n\n\n\n\nStore:flush\n\u00b6\n\n\nstore:flush() -> nil\n\n\n\n\nFlushes the store's pending actions, firing the \nchanged\n event if necessary.\n\n\n\n\nInfo\n\n\nflush\n is called by Rodux automatically every frame and usually doesn't need to be called manually.\n\n\n\n\nSignal\n\u00b6\n\n\nThe Signal class in Rodux represents a simple, predictable event that is controlled from within Rodux. It cannot be created outside of Rodux, but is used as \nStore.changed\n.\n\n\nSignal:connect\n\u00b6\n\n\nsignal:connect(listener) -> { disconnect }\n\n\n\n\nConnects a listener to the signal. The listener will be invoked whenever the signal is fired.\n\n\nconnect\n returns a table with a \ndisconnect\n function that can be used to disconnect the listener from the signal.\n\n\nHelper functions\n\u00b6\n\n\nRodux supplies some helper functions to make creating complex reducers easier.\n\n\nRodux.combineReducers\n\u00b6\n\n\nA helper function that can be used to combine multiple reducers into a new reducer.\n\n\nlocal\n \nreducer\n \n=\n \ncombineReducers\n({\n\n    \nkey1\n \n=\n \nreducer1\n,\n\n    \nkey2\n \n=\n \nreducer2\n,\n\n\n})\n\n\n\n\n\ncombineReducers\n is functionally equivalent to writing:\n\n\nlocal\n \nfunction\n \nreducer\n(\nstate\n,\n \naction\n)\n\n    \nreturn\n \n{\n\n        \nkey1\n \n=\n \nreducer1\n(\nstate\n.\nkey1\n,\n \naction\n),\n\n        \nkey2\n \n=\n \nreducer2\n(\nstate\n.\nkey2\n,\n \naction\n),\n\n    \n}\n\n\nend\n\n\n\n\n\nRodux.createReducer\n\u00b6\n\n\nRodux.createReducer(initialState, actionHandlers) -> reducer\n\n\n\n\nA helper function that can be used to create reducers.\n\n\nUnlike JavaScript, Lua has no \nswitch\n statement, which can make writing reducers that respond to lots of actions clunky.\n\n\nReducers often have a structure that looks like this:\n\n\nlocal\n \ninitialState\n \n=\n \n{}\n\n\n\nlocal\n \nfunction\n \nreducer\n(\nstate\n,\n \naction\n)\n\n    \nstate\n \n=\n \nstate\n \nor\n \ninitialState\n\n\n    \nif\n \naction\n.\ntype\n \n==\n \n\"setFoo\"\n \nthen\n\n        \n-- Handle the setFoo action\n\n    \nelseif\n \naction\n.\ntype\n \n==\n \n\"setBar\"\n \nthen\n\n        \n-- Handle the setBar action\n\n    \nend\n\n\n    \nreturn\n \nstate\n\n\nend\n\n\n\n\n\ncreateReducer\n can replace the chain of \nif\n statements in a reducer:\n\n\nlocal\n \ninitialState\n \n=\n \n{}\n\n\n\nlocal\n \nreducer\n \n=\n \ncreateReducer\n(\ninitialState\n,\n \n{\n\n    \nsetFoo\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n        \n-- Handle the setFoo action\n\n    \nend\n,\n\n\n    \nsetBar\n \n=\n \nfunction\n(\nstate\n,\n \naction\n)\n\n        \n-- Handle the setBar action\n\n    \nend\n\n\n})\n\n\n\n\n\nMiddleware\n\u00b6\n\n\nRodux provides an API that allows changing the way that actions are dispatched called \nmiddleware\n. To attach middleware to a store, pass a list of middleware as the third argument to \nStore.new\n.\n\n\n\n\nWarn\n\n\nThe middleware API changed in \n#29\n -- middleware written against the old API will not work!\n\n\n\n\nA single middleware is just a function with the following signature:\n\n\n(nextDispatch, store) -> (action) -> result\n\n\n\n\nA middleware is a function that accepts the next dispatch function in the \nmiddleware chain\n, as well as the store the middleware is being used with, and returns a new function. That function is called whenever an action is dispatched and can dispatch more actions, log to output, or perform any other side effects!\n\n\nA simple version of Rodux's \nloggerMiddleware\n is as easy as:\n\n\nlocal\n \nfunction\n \nsimpleLogger\n(\nnextDispatch\n,\n \nstore\n)\n\n    \nreturn\n \nfunction\n(\naction\n)\n\n        \nprint\n(\n\"Dispatched action of type\"\n,\n \naction\n.\ntype\n)\n\n\n        \nreturn\n \nnextDispatch\n(\naction\n)\n\n    \nend\n\n\nend\n\n\n\n\n\nRodux also ships with several middleware that address common use-cases.\n\n\nTo apply middleware, pass a list of middleware as the third argument to \nStore.new\n:\n\n\nlocal\n \nstore\n \n=\n \nStore\n.\nnew\n(\nreducer\n,\n \ninitialState\n,\n \n{\n \nsimpleLogger\n \n})\n\n\n\n\n\nMiddleware runs from left to right when an action is dispatched. That means that if a middleware does not call \nnextDispatch\n when handling an action, any middleware after it will not run.\n\n\nRodux.loggerMiddleware\n\u00b6\n\n\nA middleware that logs actions and the new state that results from them.\n\n\nloggerMiddleware\n is useful for getting a quick look at what actions are being dispatched. In the future, Rodux will have tools similar to \nRedux's DevTools\n.\n\n\nlocal\n \nstore\n \n=\n \nStore\n.\nnew\n(\nreducer\n,\n \ninitialState\n,\n \n{\n \nloggerMiddleware\n \n})\n\n\n\n\n\nRodux.thunkMiddleware\n\u00b6\n\n\nA middleware that allows thunks to be dispatched. Thunks are functions that perform asynchronous tasks or side effects, and can dispatch actions.\n\n\nthunkMiddleware\n is comparable to Redux's \nredux-thunk\n.\n\n\nlocal\n \nstore\n \n=\n \nStore\n.\nnew\n(\nreducer\n,\n \ninitialState\n,\n \n{\n \nthunkMiddleware\n \n})\n\n\n\nstore\n:\ndispatch\n(\nfunction\n(\nstore\n)\n\n    \nprint\n(\n\"Hello from a thunk!\"\n)\n\n\n    \nstore\n:\ndispatch\n({\n\n        \ntype\n \n=\n \n\"thunkAction\"\n\n    \n})\n\n\nend\n)",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#rodux-api-reference",
            "text": "",
            "title": "Rodux API Reference"
        },
        {
            "location": "/api-reference/#roduxstore",
            "text": "The Store class is the core piece of Rodux. It is the state container that you create and use.",
            "title": "Rodux.Store"
        },
        {
            "location": "/api-reference/#storenew",
            "text": "Store.new(reducer, [initialState, [middlewares]]) -> Store  Creates and returns a new Store.   reducer  is the store's root reducer function, and is invokved whenever an action is dispatched. It must be a pure function.  initialState  is the store's initial state. This should be used to load a saved state from storage.  middlewares  is a list of middleware to apply to the store.   The store will automatically dispatch an initialization action with a  type  of  @@INIT .   Note  The initialization action does not pass through any middleware prior to reaching the reducer.",
            "title": "Store.new"
        },
        {
            "location": "/api-reference/#storechanged",
            "text": "store . changed : connect ( function ( newState ,   oldState ) \n     -- do something with newState or oldState  end )   A  Signal  that is fired when the store's state is changed up to once per frame.   Warning  Multiple actions can be grouped together into one changed event!    Danger  Do not yield within any listeners on  changed ; an error will be thrown.",
            "title": "Store.changed"
        },
        {
            "location": "/api-reference/#storedispatch",
            "text": "store:dispatch(action) -> nil  Dispatches an action. The action will travel through all of the store's middlewares before reaching the store's reducer.  Unless handled by middleware,  action  must contain a  type  field to indicate what type of action it is. No other fields are required.",
            "title": "Store:dispatch"
        },
        {
            "location": "/api-reference/#storegetstate",
            "text": "store:getState() -> table  Gets the store's current state.   Warning  Do not modify this state! Doing so will cause  serious  bugs your code!",
            "title": "Store:getState"
        },
        {
            "location": "/api-reference/#storedestruct",
            "text": "store:destruct() -> nil  Destroys the store, cleaning up its connections.   Danger  Attempting to use the store after  destruct  has been called will cause problems.",
            "title": "Store:destruct"
        },
        {
            "location": "/api-reference/#storeflush",
            "text": "store:flush() -> nil  Flushes the store's pending actions, firing the  changed  event if necessary.   Info  flush  is called by Rodux automatically every frame and usually doesn't need to be called manually.",
            "title": "Store:flush"
        },
        {
            "location": "/api-reference/#signal",
            "text": "The Signal class in Rodux represents a simple, predictable event that is controlled from within Rodux. It cannot be created outside of Rodux, but is used as  Store.changed .",
            "title": "Signal"
        },
        {
            "location": "/api-reference/#signalconnect",
            "text": "signal:connect(listener) -> { disconnect }  Connects a listener to the signal. The listener will be invoked whenever the signal is fired.  connect  returns a table with a  disconnect  function that can be used to disconnect the listener from the signal.",
            "title": "Signal:connect"
        },
        {
            "location": "/api-reference/#helper-functions",
            "text": "Rodux supplies some helper functions to make creating complex reducers easier.",
            "title": "Helper functions"
        },
        {
            "location": "/api-reference/#roduxcombinereducers",
            "text": "A helper function that can be used to combine multiple reducers into a new reducer.  local   reducer   =   combineReducers ({ \n     key1   =   reducer1 , \n     key2   =   reducer2 ,  })   combineReducers  is functionally equivalent to writing:  local   function   reducer ( state ,   action ) \n     return   { \n         key1   =   reducer1 ( state . key1 ,   action ), \n         key2   =   reducer2 ( state . key2 ,   action ), \n     }  end",
            "title": "Rodux.combineReducers"
        },
        {
            "location": "/api-reference/#roduxcreatereducer",
            "text": "Rodux.createReducer(initialState, actionHandlers) -> reducer  A helper function that can be used to create reducers.  Unlike JavaScript, Lua has no  switch  statement, which can make writing reducers that respond to lots of actions clunky.  Reducers often have a structure that looks like this:  local   initialState   =   {}  local   function   reducer ( state ,   action ) \n     state   =   state   or   initialState \n\n     if   action . type   ==   \"setFoo\"   then \n         -- Handle the setFoo action \n     elseif   action . type   ==   \"setBar\"   then \n         -- Handle the setBar action \n     end \n\n     return   state  end   createReducer  can replace the chain of  if  statements in a reducer:  local   initialState   =   {}  local   reducer   =   createReducer ( initialState ,   { \n     setFoo   =   function ( state ,   action ) \n         -- Handle the setFoo action \n     end , \n\n     setBar   =   function ( state ,   action ) \n         -- Handle the setBar action \n     end  })",
            "title": "Rodux.createReducer"
        },
        {
            "location": "/api-reference/#middleware",
            "text": "Rodux provides an API that allows changing the way that actions are dispatched called  middleware . To attach middleware to a store, pass a list of middleware as the third argument to  Store.new .   Warn  The middleware API changed in  #29  -- middleware written against the old API will not work!   A single middleware is just a function with the following signature:  (nextDispatch, store) -> (action) -> result  A middleware is a function that accepts the next dispatch function in the  middleware chain , as well as the store the middleware is being used with, and returns a new function. That function is called whenever an action is dispatched and can dispatch more actions, log to output, or perform any other side effects!  A simple version of Rodux's  loggerMiddleware  is as easy as:  local   function   simpleLogger ( nextDispatch ,   store ) \n     return   function ( action ) \n         print ( \"Dispatched action of type\" ,   action . type ) \n\n         return   nextDispatch ( action ) \n     end  end   Rodux also ships with several middleware that address common use-cases.  To apply middleware, pass a list of middleware as the third argument to  Store.new :  local   store   =   Store . new ( reducer ,   initialState ,   {   simpleLogger   })   Middleware runs from left to right when an action is dispatched. That means that if a middleware does not call  nextDispatch  when handling an action, any middleware after it will not run.",
            "title": "Middleware"
        },
        {
            "location": "/api-reference/#roduxloggermiddleware",
            "text": "A middleware that logs actions and the new state that results from them.  loggerMiddleware  is useful for getting a quick look at what actions are being dispatched. In the future, Rodux will have tools similar to  Redux's DevTools .  local   store   =   Store . new ( reducer ,   initialState ,   {   loggerMiddleware   })",
            "title": "Rodux.loggerMiddleware"
        },
        {
            "location": "/api-reference/#roduxthunkmiddleware",
            "text": "A middleware that allows thunks to be dispatched. Thunks are functions that perform asynchronous tasks or side effects, and can dispatch actions.  thunkMiddleware  is comparable to Redux's  redux-thunk .  local   store   =   Store . new ( reducer ,   initialState ,   {   thunkMiddleware   })  store : dispatch ( function ( store ) \n     print ( \"Hello from a thunk!\" ) \n\n     store : dispatch ({ \n         type   =   \"thunkAction\" \n     })  end )",
            "title": "Rodux.thunkMiddleware"
        }
    ]
}