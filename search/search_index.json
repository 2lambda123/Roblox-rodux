{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rodux is a central state management library based on Dan Abramov's Redux library for JavaScript. It exposes a very similar API and implements nearly identical semantics. This documentation is based on the structure of Redux's documentation, but is a work in progress. Many things from Redux also apply to Rodux, but if you find anything missing or incorrect, open an issue on GitHub ! Info This documentation assumes some familiarity with Lua. If you're new to Lua, Programming in Lua by Roberto Ierusalimschy is a good introduction, and the first edition (for Lua 5.0) is available online for free.","title":"Home"},{"location":"api-reference/","text":"Rodux API Reference \u00b6 Rodux.Store \u00b6 The Store class is the core piece of Rodux. It is the state container that you create and use. Store.new \u00b6 Store.new(reducer, [initialState, [middlewares, [errorReporter]]]) -> Store Creates and returns a new Store. reducer is the store's root reducer function, and is invoked whenever an action is dispatched. It must be a pure function. initialState is the store's initial state. This should be used to load a saved state from storage. middlewares is a list of middleware functions to apply each time an action is dispatched to the store. errorReporter is a error reporter object that allows custom handling of errors that occur during different phases of the store's updates The store will automatically dispatch an initialization action with a type of @@INIT . Note The initialization action does not pass through any middleware prior to reaching the reducer. Store.changed \u00b6 store . changed : connect ( function ( newState , oldState ) -- do something with newState or oldState end ) A Signal that is fired when the store's state is changed up to once per frame. Warning Multiple actions can be grouped together into one changed event! Danger Do not yield within any listeners on changed ; an error will be thrown. Store:dispatch \u00b6 store:dispatch(action) -> nil Dispatches an action. The action will travel through all of the store's middlewares before reaching the store's reducer. Unless handled by middleware, action must contain a type field to indicate what type of action it is. No other fields are required. Store:getState \u00b6 store:getState() -> table Gets the store's current state. Warning Do not modify this state! Doing so will cause serious bugs your code! Store:destruct \u00b6 store:destruct() -> nil Destroys the store, cleaning up its connections. Danger Attempting to use the store after destruct has been called will cause problems. Store:flush \u00b6 store:flush() -> nil Flushes the store's pending actions, firing the changed event if necessary. Info flush is called by Rodux automatically every frame and usually doesn't need to be called manually. Signal \u00b6 The Signal class in Rodux represents a simple, predictable event that is controlled from within Rodux. It cannot be created outside of Rodux, but is used as Store.changed . Signal:connect \u00b6 signal:connect(listener) -> { disconnect } Connects a listener to the signal. The listener will be invoked whenever the signal is fired. connect returns a table with a disconnect function that can be used to disconnect the listener from the signal. Helper functions \u00b6 Rodux supplies some helper functions to make creating complex reducers easier. Rodux.combineReducers \u00b6 A helper function that can be used to combine multiple reducers into a new reducer. local reducer = combineReducers ({ key1 = reducer1 , key2 = reducer2 , }) combineReducers is functionally equivalent to writing: local function reducer ( state , action ) return { key1 = reducer1 ( state . key1 , action ), key2 = reducer2 ( state . key2 , action ), } end Rodux.createReducer \u00b6 Rodux.createReducer(initialState, actionHandlers) -> reducer A helper function that can be used to create reducers. Unlike JavaScript, Lua has no switch statement, which can make writing reducers that respond to lots of actions clunky. Reducers often have a structure that looks like this: local initialState = {} local function reducer ( state , action ) state = state or initialState if action . type == \"setFoo\" then -- Handle the setFoo action elseif action . type == \"setBar\" then -- Handle the setBar action end return state end createReducer can replace the chain of if statements in a reducer: local initialState = {} local reducer = createReducer ( initialState , { setFoo = function ( state , action ) -- Handle the setFoo action end , setBar = function ( state , action ) -- Handle the setBar action end }) Rodux.makeActionCreator \u00b6 Rodux.makeActionCreator(name, actionGeneratorFunction) -> actionCreator A helper function that can be used to make action creators. Action creators are helper objects that will generate actions from provided data and automatically populate the type field. Actions often have a structure that looks like this: local MyAction = { type = \"SetFoo\" , value = 1 , } They are often generated by functions that take the action's data as arguments: local function SetFoo ( value ) return { type = \"SetFoo\" , value = value , } end makeActionCreator looks similar, but it automatically populates the action's type with the action creator's name. This makes it easier to keep track of which actions your reducers are responding to: Make an action creator in SetFoo.lua : return makeActionCreator ( \"SetFoo\" , function ( value ) -- The action creator will automatically add the 'type' field return { value = value , } end ) Then check for that action by name in FooReducer.lua : local SetFoo = require ( SetFoo ) ... if action . type == SetFoo . name then -- change some state! end Middleware \u00b6 Rodux provides an API that allows changing the way that actions are dispatched called middleware . To attach middleware to a store, pass a list of middleware as the third argument to Store.new . Warn The middleware API changed in #29 -- middleware written against the old API will not work! A single middleware is just a function with the following signature: (nextDispatch, store) -> (action) -> result A middleware is a function that accepts the next dispatch function in the middleware chain , as well as the store the middleware is being used with, and returns a new function. That function is called whenever an action is dispatched and can dispatch more actions, log to output, or perform any other side effects! A simple version of Rodux's loggerMiddleware is as easy as: local function simpleLogger ( nextDispatch , store ) return function ( action ) print ( \"Dispatched action of type\" , action . type ) return nextDispatch ( action ) end end Rodux also ships with several middleware that address common use-cases. To apply middleware, pass a list of middleware as the third argument to Store.new : local store = Store . new ( reducer , initialState , { simpleLogger }) Middleware runs from left to right when an action is dispatched. That means that if a middleware does not call nextDispatch when handling an action, any middleware after it will not run. For a more detailed example, see the middleware guide . Rodux.loggerMiddleware \u00b6 A middleware that logs actions and the new state that results from them. loggerMiddleware is useful for getting a quick look at what actions are being dispatched. In the future, Rodux will have tools similar to Redux's DevTools . local store = Store . new ( reducer , initialState , { loggerMiddleware }) Rodux.thunkMiddleware \u00b6 A middleware that allows thunks to be dispatched. Thunks are functions that perform asynchronous tasks or side effects, and can dispatch actions. thunkMiddleware is comparable to Redux's redux-thunk . local store = Store . new ( reducer , initialState , { thunkMiddleware }) store : dispatch ( function ( store ) print ( \"Hello from a thunk!\" ) store : dispatch ({ type = \"thunkAction\" }) end ) Rodux.makeThunkMiddleware (unreleased) \u00b6 Rodux.makeThunkMiddleware(extraArgument) -> thunkMiddleware A function that creates a thunk middleware that injects a custom argument when invoking thunks (in addition to the store itself). This is useful for cases like using an API service layer that could be swapped out for a mock service in tests. local myThunkMiddleware = Rodux . makeThunkMiddleware ( myCustomArg ) local store = Store . new ( reducer , initialState , { myThunkMiddleware }) store : dispatch ( function ( store , myCustomArg ) print ( \"Hello from a thunk with extra argument:\" , myCustomArg ) store : dispatch ({ type = \"thunkAction\" }) end ) Error Reporters \u00b6 In version 3.0.0+, the Rodux store can be provided with a custom error reporter. This is a good entry point to enable improved logging, debugging, and analytics. The error reporter interface is an object with two functions: reportReducerError \u00b6 reportReducerError(prevState, action, errorResult) -> () Called when an error is thrown while processing an action through the reducer. If thunk middleware is included, errors encountered while executing thunks will also be caught and reported through this function. The function receives these arguments: prevState - the last known state value for the store. Since this reporter catches errors that occurred before the reducer finished resolving, the prevState value will be equal to the store state before the action was processed action - the action that was being processed when the error occurred errorResult - an object describing the error that was caught The default error reporter will simply rethrow the value from the caught errorResult. reportUpdateError \u00b6 reportUpdateError(prevState, currentState, actionLog, errorResult) -> () Called when an error is thrown while updating listeners subscribed to the store state. Rodux flushes actions on a regular interval rather than synchronously, so there may be several actions queued up before each flush. The last 3 actions that were received before the current flush are provided to the error reporter. This is currently hard coded in the store logic, but could be overridden with an option in the future if it's useful to do so. The function receives these arguments: prevState - the last known state that was flushed to consumers before the update that produced the error currentState - the new store state that was being flushed to consumers when the error occurred. Some consumers may have already processed to this new state by the time the reporter is called actionLog - an array containing the last three actions that were dispatched to the store, sorted from oldest to newest errorResult - an object describing the error that was caught The default error reporter will simply rethrow the value from the caught errorResult.","title":"API Reference"},{"location":"api-reference/#rodux-api-reference","text":"","title":"Rodux API Reference"},{"location":"api-reference/#roduxstore","text":"The Store class is the core piece of Rodux. It is the state container that you create and use.","title":"Rodux.Store"},{"location":"api-reference/#storenew","text":"Store.new(reducer, [initialState, [middlewares, [errorReporter]]]) -> Store Creates and returns a new Store. reducer is the store's root reducer function, and is invoked whenever an action is dispatched. It must be a pure function. initialState is the store's initial state. This should be used to load a saved state from storage. middlewares is a list of middleware functions to apply each time an action is dispatched to the store. errorReporter is a error reporter object that allows custom handling of errors that occur during different phases of the store's updates The store will automatically dispatch an initialization action with a type of @@INIT . Note The initialization action does not pass through any middleware prior to reaching the reducer.","title":"Store.new"},{"location":"api-reference/#storechanged","text":"store . changed : connect ( function ( newState , oldState ) -- do something with newState or oldState end ) A Signal that is fired when the store's state is changed up to once per frame. Warning Multiple actions can be grouped together into one changed event! Danger Do not yield within any listeners on changed ; an error will be thrown.","title":"Store.changed"},{"location":"api-reference/#storedispatch","text":"store:dispatch(action) -> nil Dispatches an action. The action will travel through all of the store's middlewares before reaching the store's reducer. Unless handled by middleware, action must contain a type field to indicate what type of action it is. No other fields are required.","title":"Store:dispatch"},{"location":"api-reference/#storegetstate","text":"store:getState() -> table Gets the store's current state. Warning Do not modify this state! Doing so will cause serious bugs your code!","title":"Store:getState"},{"location":"api-reference/#storedestruct","text":"store:destruct() -> nil Destroys the store, cleaning up its connections. Danger Attempting to use the store after destruct has been called will cause problems.","title":"Store:destruct"},{"location":"api-reference/#storeflush","text":"store:flush() -> nil Flushes the store's pending actions, firing the changed event if necessary. Info flush is called by Rodux automatically every frame and usually doesn't need to be called manually.","title":"Store:flush"},{"location":"api-reference/#signal","text":"The Signal class in Rodux represents a simple, predictable event that is controlled from within Rodux. It cannot be created outside of Rodux, but is used as Store.changed .","title":"Signal"},{"location":"api-reference/#signalconnect","text":"signal:connect(listener) -> { disconnect } Connects a listener to the signal. The listener will be invoked whenever the signal is fired. connect returns a table with a disconnect function that can be used to disconnect the listener from the signal.","title":"Signal:connect"},{"location":"api-reference/#helper-functions","text":"Rodux supplies some helper functions to make creating complex reducers easier.","title":"Helper functions"},{"location":"api-reference/#roduxcombinereducers","text":"A helper function that can be used to combine multiple reducers into a new reducer. local reducer = combineReducers ({ key1 = reducer1 , key2 = reducer2 , }) combineReducers is functionally equivalent to writing: local function reducer ( state , action ) return { key1 = reducer1 ( state . key1 , action ), key2 = reducer2 ( state . key2 , action ), } end","title":"Rodux.combineReducers"},{"location":"api-reference/#roduxcreatereducer","text":"Rodux.createReducer(initialState, actionHandlers) -> reducer A helper function that can be used to create reducers. Unlike JavaScript, Lua has no switch statement, which can make writing reducers that respond to lots of actions clunky. Reducers often have a structure that looks like this: local initialState = {} local function reducer ( state , action ) state = state or initialState if action . type == \"setFoo\" then -- Handle the setFoo action elseif action . type == \"setBar\" then -- Handle the setBar action end return state end createReducer can replace the chain of if statements in a reducer: local initialState = {} local reducer = createReducer ( initialState , { setFoo = function ( state , action ) -- Handle the setFoo action end , setBar = function ( state , action ) -- Handle the setBar action end })","title":"Rodux.createReducer"},{"location":"api-reference/#roduxmakeactioncreator","text":"Rodux.makeActionCreator(name, actionGeneratorFunction) -> actionCreator A helper function that can be used to make action creators. Action creators are helper objects that will generate actions from provided data and automatically populate the type field. Actions often have a structure that looks like this: local MyAction = { type = \"SetFoo\" , value = 1 , } They are often generated by functions that take the action's data as arguments: local function SetFoo ( value ) return { type = \"SetFoo\" , value = value , } end makeActionCreator looks similar, but it automatically populates the action's type with the action creator's name. This makes it easier to keep track of which actions your reducers are responding to: Make an action creator in SetFoo.lua : return makeActionCreator ( \"SetFoo\" , function ( value ) -- The action creator will automatically add the 'type' field return { value = value , } end ) Then check for that action by name in FooReducer.lua : local SetFoo = require ( SetFoo ) ... if action . type == SetFoo . name then -- change some state! end","title":"Rodux.makeActionCreator"},{"location":"api-reference/#middleware","text":"Rodux provides an API that allows changing the way that actions are dispatched called middleware . To attach middleware to a store, pass a list of middleware as the third argument to Store.new . Warn The middleware API changed in #29 -- middleware written against the old API will not work! A single middleware is just a function with the following signature: (nextDispatch, store) -> (action) -> result A middleware is a function that accepts the next dispatch function in the middleware chain , as well as the store the middleware is being used with, and returns a new function. That function is called whenever an action is dispatched and can dispatch more actions, log to output, or perform any other side effects! A simple version of Rodux's loggerMiddleware is as easy as: local function simpleLogger ( nextDispatch , store ) return function ( action ) print ( \"Dispatched action of type\" , action . type ) return nextDispatch ( action ) end end Rodux also ships with several middleware that address common use-cases. To apply middleware, pass a list of middleware as the third argument to Store.new : local store = Store . new ( reducer , initialState , { simpleLogger }) Middleware runs from left to right when an action is dispatched. That means that if a middleware does not call nextDispatch when handling an action, any middleware after it will not run. For a more detailed example, see the middleware guide .","title":"Middleware"},{"location":"api-reference/#roduxloggermiddleware","text":"A middleware that logs actions and the new state that results from them. loggerMiddleware is useful for getting a quick look at what actions are being dispatched. In the future, Rodux will have tools similar to Redux's DevTools . local store = Store . new ( reducer , initialState , { loggerMiddleware })","title":"Rodux.loggerMiddleware"},{"location":"api-reference/#roduxthunkmiddleware","text":"A middleware that allows thunks to be dispatched. Thunks are functions that perform asynchronous tasks or side effects, and can dispatch actions. thunkMiddleware is comparable to Redux's redux-thunk . local store = Store . new ( reducer , initialState , { thunkMiddleware }) store : dispatch ( function ( store ) print ( \"Hello from a thunk!\" ) store : dispatch ({ type = \"thunkAction\" }) end )","title":"Rodux.thunkMiddleware"},{"location":"api-reference/#roduxmakethunkmiddleware-unreleased","text":"Rodux.makeThunkMiddleware(extraArgument) -> thunkMiddleware A function that creates a thunk middleware that injects a custom argument when invoking thunks (in addition to the store itself). This is useful for cases like using an API service layer that could be swapped out for a mock service in tests. local myThunkMiddleware = Rodux . makeThunkMiddleware ( myCustomArg ) local store = Store . new ( reducer , initialState , { myThunkMiddleware }) store : dispatch ( function ( store , myCustomArg ) print ( \"Hello from a thunk with extra argument:\" , myCustomArg ) store : dispatch ({ type = \"thunkAction\" }) end )","title":"Rodux.makeThunkMiddleware (unreleased)"},{"location":"api-reference/#error-reporters","text":"In version 3.0.0+, the Rodux store can be provided with a custom error reporter. This is a good entry point to enable improved logging, debugging, and analytics. The error reporter interface is an object with two functions:","title":"Error Reporters"},{"location":"api-reference/#reportreducererror","text":"reportReducerError(prevState, action, errorResult) -> () Called when an error is thrown while processing an action through the reducer. If thunk middleware is included, errors encountered while executing thunks will also be caught and reported through this function. The function receives these arguments: prevState - the last known state value for the store. Since this reporter catches errors that occurred before the reducer finished resolving, the prevState value will be equal to the store state before the action was processed action - the action that was being processed when the error occurred errorResult - an object describing the error that was caught The default error reporter will simply rethrow the value from the caught errorResult.","title":"reportReducerError"},{"location":"api-reference/#reportupdateerror","text":"reportUpdateError(prevState, currentState, actionLog, errorResult) -> () Called when an error is thrown while updating listeners subscribed to the store state. Rodux flushes actions on a regular interval rather than synchronously, so there may be several actions queued up before each flush. The last 3 actions that were received before the current flush are provided to the error reporter. This is currently hard coded in the store logic, but could be overridden with an option in the future if it's useful to do so. The function receives these arguments: prevState - the last known state that was flushed to consumers before the update that produced the error currentState - the new store state that was being flushed to consumers when the error occurred. Some consumers may have already processed to this new state by the time the reporter is called actionLog - an array containing the last three actions that were dispatched to the store, sorted from oldest to newest errorResult - an object describing the error that was caught The default error reporter will simply rethrow the value from the caught errorResult.","title":"reportUpdateError"},{"location":"debugging/","text":"In the future, Rodux will have tools similar to Redux's DevTools and will be documented here. For now, we highly recommend using the loggerMiddleware to observe the state as action objects are dispatched to your store .","title":"Debugging"},{"location":"example/","text":"The following is an example of a Rodux store that keeps track of the current user's phone number and the names of their friends. It demonstrates the use of the Rodux store , actions , reducers , and middleware in a real world setting. The loggerMiddleware has been included to demonstrate how to include middleware in your store and to provide valuable output in response to dispatched action objects. Info This example assumes that you've successfully installed Rodux into ReplicatedStorage and placed the contents of the following in a LocalScript under StarterPlayer/StarterPlayerScripts ! local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Rodux = require ( ReplicatedStorage . Rodux ) -- Action creator for the ReceivedNewPhoneNumber action local function ReceivedNewPhoneNumber ( phoneNumber ) return { type = \"ReceivedNewPhoneNumber\" , phoneNumber = phoneNumber , } end -- Action creator for the MadeNewFriends action local function MadeNewFriends ( listOfNewFriends ) return { type = \"MadeNewFriends\" , newFriends = listOfNewFriends , } end -- Reducer for the current user's phone number local phoneNumberReducer = Rodux . createReducer ( \"\" , { ReceivedNewPhoneNumber = function ( state , action ) return action . phoneNumber end , }) -- Reducer for the current user's list of friends local friendsReducer = Rodux . createReducer ({}, { MadeNewFriends = function ( state , action ) local newState = {} -- Since state is read-only, we copy it into newState for index , friend in ipairs ( state ) do newState [ index ] = friend end for _ , friend in ipairs ( action . newFriends ) do table.insert ( newState , friend ) end return newState end , }) local reducer = Rodux . combineReducers ({ myPhoneNumber = phoneNumberReducer , myFriends = friendsReducer , }) local store = Rodux . Store . new ( reducer , nil , { Rodux . loggerMiddleware , }) store : dispatch ( ReceivedNewPhoneNumber ( \"15552345678\" )) store : dispatch ( MadeNewFriends ({ \"Cassandra\" , \"Joe\" , })) --[[ Expected output to the developer console: Action dispatched: { phoneNumber = \"12345678\" (string) type = \"ReceivedNewPhoneNumber\" (string) } State changed to: { myPhoneNumber = \"12345678\" (string) myFriends = { } } Action dispatched: { newFriends = { 1 = \"Cassandra\" (string) 2 = \"Joe\" (string) } type = \"MadeNewFriends\" (string) } State changed to: { myPhoneNumber = \"12345678\" (string) myFriends = { 1 = \"Cassandra\" (string) 2 = \"Joe\" (string) } } ]]","title":"Complete Example"},{"location":"withroact/","text":"Rodux stands well on its own and does not require any additional libraries. However, Rodux can be particularly useful when developing Roact applications. It is difficult to represent global state in Roact without passing a lot of data up and down the Roact DOM. RoactRodux allows us to connect individual Roact components to our Rodux store, simplifying the management of our application's global state.","title":"Usage with Roact"},{"location":"advanced/error-reporters/","text":"When Rodux encounters errors during action processing or when updating consumers, it will rethrow them by default. In some cases, you may want to intercept errors and record them somewhere useful, often with additional context. The Rodux.Store.new function accepts an optional errorReporter object with the following shape: ErrorReporter = { reportReducerError(prevState, action, errorResult) -> (), reportUpdateError(prevState, currentState, actionLog, errorResult) -> (), } The default implementation used by rodux looks like this: local rethrowErrorReporter = { reportReducerError = function ( prevState , action , errorResult ) error ( string.format ( \"Received error: %s \\n\\n %s\" , errorResult . message , errorResult . thrownValue )) end , reportUpdateError = function ( prevState , currentState , lastActions , errorResult ) error ( string.format ( \"Received error: %s \\n\\n %s\" , errorResult . message , errorResult . thrownValue )) end , } In practice, you might use a custom error reporter to send detailed error information to an analytics endpoint: -- This example supposes that we have some utilities for serializing the store -- objects that were involved when an error was thrown local inspectObject = require ( MyUtils . inspectObject ) local tableDiff = require ( MyUtils . tableDiff ) local sendToAnalyticsBackend = require ( MyUtils . sendToAnalyticsBackend ) local rethrowErrorReporter = { reportReducerError = function ( prevState , action , errorResult ) local message = string.format ( \"%s \\n\\n Action: \\n %s \\n\\n Error contents: \\n %s\" , errorResult . message , inspectObject ( action ), tostring ( errorResult . thrownValue ) ) sendToAnalyticsBackend ( message ) end , reportUpdateError = function ( prevState , currentState , lastActions , errorResult ) local message = string.format ( \"%s \\n\\n \" .. \"Store changes in the last flush: \\n %s \\n\\n \" .. \"Most recent actions (starting with the oldest): \\n %s \\n\\n \" .. \"Error contents: \\n %s\" , errorResult . message , inspectObject ( tableDiff ( prevState , currentState )), inspectObject ( actionLog ), tostring ( errorResult . thrownValue ) ) sendToAnalyticsBackend ( message ) end , }","title":"Error Reporters"},{"location":"advanced/middleware/","text":"Most of the time, calling Store:dispatch sends incoming action objects directly to the reducer to determine what updates should be made to the state . This is enough for most cases, but some features would be difficult to implement if this was all Rodux provided. For example: Delayed processing of an action . Logging action objects dispatched to our store . Performing a network request in response to an action and storing the response in the state . Rodux has the concept of middleware to deal with these sorts of situations. A middleware is a function that accepts the next dispatch function in the middleware chain, as well as the store the middleware is being used with, and returns a new function. That function is called whenever an action is dispatched and can dispatch more actions , log to output, or perform any other side effects! When an action is dispatched, middleware are run in the order they were specified in Store.new from left to right. Here is an example of a middleware that could be used to delay the processing of action objects dispatched to the store . local reducer = function ( state , action ) -- the body of your reducer end local initialState = {} local delayOneSecondMiddleware = function ( nextDispatch , store ) return function ( action ) delay ( 1 , function () --[[ nextDispatch passes the action to the next middleware provided to the store at initialization or to the reducer if the action has already been processed by all the provided middleware. ]] nextDispatch ( action ) end ) end end local store = Rodux . Store . new ( reducer , initialState , { delayOneSecondMiddleware , }) Warning If the delayOneSecondMiddleware function did not call nextDispatch , then the action would not be processed by any other middleware in the middleware chain or our reducer ! Rodux has two middlewares available to you out of the box. See Middleware , thunkMiddleware , and loggerMiddleware for more details.","title":"Middleware"},{"location":"advanced/thunks/","text":"The thunkMiddleware packaged with Rodux will intercept any action dispatched to our store that is a Lua function and execute that function instead of forwarding our action to the reducer . These functions (also called thunks) have access to the store and are allowed to dispatch action objects themselves as necessary. local reducer = function ( state , action ) --[[ Reducer that handles all actions for our store, including actions of the type \"MadeNewFriends\". ]] end local initialState = {} local store = Rodux . Store . new ( reducer , initialState , { Rodux . thunkMiddleware , }) --[[ Our thunkMiddleware will process this action as a thunk since it is a Lua function ]] store : dispatch ( function ( store ) getAsyncNewFriendsForUser ( \"Sarah\" , function ( result ) store : dispatch ({ type = \"MadeNewFriends\" , newFriends = result , }) end ) end ) Thunks are a simple way to introduce more complex processing of action objects, but you may want to consider creating custom middleware for complex features instead of relying on thunks alone. It is also possible to inject a custom argument into the thunk middleware. This is useful for cases like using an API service layer that could be swapped out for a mock service in tests. This is accomplished by using the Rodux.makeThunkMiddleware API instead: local myThunkMiddleware = Rodux . makeThunkMiddleware ( myCustomArg ) local store = Rodux . Store . new ( reducer , initialState , { myThunkMiddleware , }) store : dispatch ( function ( store , myCustomArg ) print ( \"Hello from a thunk with extra argument:\" , myCustomArg ) store : dispatch ({ type = \"thunkAction\" }) end ) If multiple values need to be passed in, they can be combined into a single table: local myThunkMiddleware = Rodux . makeThunkMiddleware ({ [ RoactNetworking ] = networking , AvatarEditorService = AvatarEditorService , })","title":"Thunks"},{"location":"introduction/actions/","text":"Whenever the state in your store needs to be updated in response to an event, you dispatch an action to your store with any relevant information required to make said update. An action is usually a Lua table with a type field. They are usually created via an action creator Lua module like the following: local function ReceivedNewPhoneNumber ( phoneNumber ) return { type = \"ReceivedNewPhoneNumber\" , phoneNumber = phoneNumber , } end return ReceivedNewPhoneNumber We can then dispatch an action to our store via Store:dispatch like so: local store = Store . new ( function ( currentState , action ) -- The body of your reducer end ) store : dispatch ( ReceivedNewPhoneNumber ( \"15552345678\" )) Info In most cases your action will be sent directly to the reducer to be processed. However, if you specified any middleware when initializing your store , your action might also be processed by that middleware . Additionally, Rodux provides a helper method called makeActionCreator to generate 'action creators'. These are a lot like the ReceivedNewPhoneNumber function above, except for two key differences: Instead of functions, action creators returned from makeActionCreator are callable tables that also include a name field. Action creators will automatically populate the type field of each action they create using their name . We can define an action creator like this: return makeActionCreator ( \"ReceivedNewPhoneNumber\" , function ( phoneNumber ) return { phoneNumber = phoneNumber , } end ) Since the name of the action creator populates the type of the actions it creates, we can use an action creators name to identify actions that were created by it. As we'll see in the Reducers section, this is helpful for determining which action we're processing: local MyAction = require ( MyAction ) ... if action . type == MyAction . name then -- change some state! end Info Actions are nothing more than tables with a type field, so there are many ways to generate them! If makeActionCreator doesn't work for your project, you can always generate actions and action creators however you like!","title":"Actions"},{"location":"introduction/installation/","text":"There are two supported ways to get started with Rodux. For our examples, we'll install Rodux to ReplicatedStorage . In practice, it's okay to install Rodux anywhere you want! Method 1: Model File (Roblox Studio) \u00b6 Download the rbxmx model file attached to the latest release from the GitHub releases page . Insert the model into Studio into a place like ReplicatedStorage Method 2: Filesystem \u00b6 Copy the src directory into your codebase Rename the folder to Rodux Use a plugin like Rojo to sync the files into a place","title":"Installation"},{"location":"introduction/installation/#method-1-model-file-roblox-studio","text":"Download the rbxmx model file attached to the latest release from the GitHub releases page . Insert the model into Studio into a place like ReplicatedStorage","title":"Method 1: Model File (Roblox Studio)"},{"location":"introduction/installation/#method-2-filesystem","text":"Copy the src directory into your codebase Rename the folder to Rodux Use a plugin like Rojo to sync the files into a place","title":"Method 2: Filesystem"},{"location":"introduction/motivation/","text":"As applications become more complex it can be difficult to manage the state of our application in a way that is transparent and compartmentalized. State changes caused by network responses and user input become difficult to follow as our business logic gets spread out between an increasing number of models and views, producing unpredictable and undesirable results. Rodux tries to address this problem by following three core principles. Single Source of Truth \u00b6 By collecting all of our application's state in a single object, we can quickly inspect the entirety of the data backing our business logic. We will no longer need to track down data models squirrelled away in disparate parts of our code base. State is Read-only \u00b6 All changes to our single state object are accomplished by dispatching actions to our store, so which part of our code caused what changes to our underlying data will be completely transparent and reproducible. Features that were once difficult like undo/redo become trivial when all changes to our data are controlled via a single, consistent interface. Changes Are Made With Pure Functions \u00b6 Actions dispatched to our store will be processed by pure functions called reducers. These reducers simply take an action and our store's current state as input and output the store's new state in response to that action. These functions have no side effects and give us a single location to put all of our business logic instead of spreading that business logic out over numerous views and models. That's all there is to it! The API and tools Rodux provides are relatively simple, but solve many of the most common problems that occur in complex, asynchronous applications by introducing a single paradigm for all of our data management.","title":"Motivation"},{"location":"introduction/motivation/#single-source-of-truth","text":"By collecting all of our application's state in a single object, we can quickly inspect the entirety of the data backing our business logic. We will no longer need to track down data models squirrelled away in disparate parts of our code base.","title":"Single Source of Truth"},{"location":"introduction/motivation/#state-is-read-only","text":"All changes to our single state object are accomplished by dispatching actions to our store, so which part of our code caused what changes to our underlying data will be completely transparent and reproducible. Features that were once difficult like undo/redo become trivial when all changes to our data are controlled via a single, consistent interface.","title":"State is Read-only"},{"location":"introduction/motivation/#changes-are-made-with-pure-functions","text":"Actions dispatched to our store will be processed by pure functions called reducers. These reducers simply take an action and our store's current state as input and output the store's new state in response to that action. These functions have no side effects and give us a single location to put all of our business logic instead of spreading that business logic out over numerous views and models. That's all there is to it! The API and tools Rodux provides are relatively simple, but solve many of the most common problems that occur in complex, asynchronous applications by introducing a single paradigm for all of our data management.","title":"Changes Are Made With Pure Functions"},{"location":"introduction/reducers/","text":"When you initialize your store with Store.new , you provide a single function called a reducer which will consume any action dispatched to your store and create a new state object based on the current state of your store . local phoneNumberReducer = function ( state , action ) if action . type == \"ReceivedNewPhoneNumber\" then return action . phoneNumber end return state end Note that state is never actually modified by our reducer . The state of our store is read-only , so our reducer must construct a new state object in response to the received action . For complex applications, it is often useful to break down the global reducer you provide to the store into a set of smaller reducer functions, each of which is responsible for a portion of the state . local friendsReducer = function ( state , action ) --[[ The state might be nil the first time this reducer is executed. In that case, we need to initialize our state to be the empty table. ]] state = state or {} if action . type == \"MadeNewFriends\" then local newState = {} -- Since state is read-only, we copy it into newState for index , friend in ipairs ( state ) do newState [ index ] = friend end for _ , friend in ipairs ( action . newFriends ) table.insert ( newState , friend ) end return newState end return state end --[[ note that the reducer for our entire application is defined by a table of sub-reducers where each sub-reducer is responsible for one portion of the overall state. ]] local reducer = function ( state , action ) return { myPhoneNumber = phoneNumberReducer ( state . myPhoneNumber , action ), myFriends = friendsReducer ( state . myFriends , action ), } end Alternatively, you can use Rodux.createReducer and Rodux.combineReducers to generate the same code as seen above. Using Rodux.createReducer and Rodux.combineReducers to create your reducer functions isn't as verbose and is less prone to developer error. local phoneNumberReducer = Rodux . createReducer ( nil , { ReceivedNewPhoneNumber = function ( state , action ) return action . phoneNumber end , }) local friendsReducer = Rodux . createReducer ({}, { MadeNewFriends = function ( state , action ) local newState = {} -- Since state is read-only, we copy it into newState for index , friend in ipairs ( state ) do newState [ index ] = friend end for _ , friend in ipairs ( action . friends ) table.insert ( newState , friend ) end return newState end , }) local reducer = Rodux . combineReducers ({ myPhoneNumber = phoneNumberReducer , myFriends = friendsReducer , })","title":"Reducers"},{"location":"introduction/store/","text":"The store is comprised of three parts and is your main entry point for all things Rodux. It is created via Store.new . State \u00b6 This is the object that contains all of the data backing the business logic of your application. It is usually represented as a Lua table and it can be read via Store:getState . local exampleState = { myPhoneNumber = \"15552345678\" , myFriends = { \"Joe\" , \"Cassandra\" , }, } Reducer \u00b6 This is a pure function that takes in an action object and the current state of your store and outputs a new state in response to the action . Reducers are often broken down into many individual pure functions, each of which modifies one portion of the state. You provide your global reducer to the store during initialization via Store.new . See the Reducer page for more details. Dispatcher \u00b6 This is the function of the store that handles incoming action objects and forwards them to your reducer . If you have applied any middleware to your store , the middleware will wrap this dispatcher function and reassign it such that the action will be passed through all of the middleware you provided to your store before forwarding the action object to the reducer . You can provide middleware to the store during initialization via Store.new . local store = Rodux . Store . new ( function ( action , currentState ) -- The body of your reducer end ) local state = store : getState ()","title":"The Store"},{"location":"introduction/store/#state","text":"This is the object that contains all of the data backing the business logic of your application. It is usually represented as a Lua table and it can be read via Store:getState . local exampleState = { myPhoneNumber = \"15552345678\" , myFriends = { \"Joe\" , \"Cassandra\" , }, }","title":"State"},{"location":"introduction/store/#reducer","text":"This is a pure function that takes in an action object and the current state of your store and outputs a new state in response to the action . Reducers are often broken down into many individual pure functions, each of which modifies one portion of the state. You provide your global reducer to the store during initialization via Store.new . See the Reducer page for more details.","title":"Reducer"},{"location":"introduction/store/#dispatcher","text":"This is the function of the store that handles incoming action objects and forwards them to your reducer . If you have applied any middleware to your store , the middleware will wrap this dispatcher function and reassign it such that the action will be passed through all of the middleware you provided to your store before forwarding the action object to the reducer . You can provide middleware to the store during initialization via Store.new . local store = Rodux . Store . new ( function ( action , currentState ) -- The body of your reducer end ) local state = store : getState ()","title":"Dispatcher"}]}